#version 330 core

uniform sampler2D texture_diffuse1;
uniform sampler2D texture_diffuse2;
uniform sampler2D texture_diffuse3;
uniform sampler2D texture_specular1;
uniform sampler2D texture_specular2;
uniform sampler2D texture_specular3;


struct Material {
  sampler2D diffuse;
  sampler2D specular;
  sampler2D emissive;
  float     shininess;
};

struct DirectionalLight {
	vec3 direction;

	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
};

struct PointLight {
	vec3 position;

	vec3 ambient;
	vec3 diffuse;
	vec3 specular;

	// -- Attenuation -- //
	float constant;
	float linear;
	float quadratic;
};

struct SpotLight {
	vec3 position;
	vec3 direction;

	vec3 ambient;
	vec3 diffuse;
	vec3 specular;

	// -- Attenuation --//
	float constant;
	float linear;
	float quadratic;
	
	float cutoff;
};


uniform DirectionalLight dirLight;


in vec3 Normal;
in vec3 FragPos; // Interpolated from 3 world pos of verts that make the triangle
in vec2 TexCoords; // (s,t) for the position on the texture


out vec4 FragColor;

uniform vec3 viewPos;
uniform Material material;

/*
normal : required because we must calculate if a frag is lit.
         a frag normal is used through multiple calculations. Thus, it makes sense we calculate
		it externally and pass it to the function.
viewDir : required bc we must calculate specular. Again, this is used with multiple per-light calculations
		  so we calculate it externally then pass it
*/
vec3 calculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDir);
/*
fragPos : required because the point light has a position. Since the frag's color depends on it's position
	      relative to the light, we need to include the frag's position as a param
*/
vec3 calculatePointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);

vec3 calculateSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);



void main()
{
	vec3 viewDir = normalize(viewPos - FragPos);

	vec3 fragColor = calculateDirectionalLight(dirLight, Normal, viewDir) ;

	FragColor = vec4(fragColor, 1.0);
};




vec3 calculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDir)
{
	vec3 norm = normalize(normal);

	float diff = max(dot(norm, -light.direction), 0.0);
	float spec = pow(max(dot(-viewDir, norm), 0.0) , material.shininess);

	vec3 Ambient  = light.ambient         * vec3(0.5, 0.5, 0.5); //vec3(texture(texture_diffuse1, TexCoords));
	vec3 Diffuse  = light.diffuse  * diff * vec3(0.5, 0.5, 0.5); //vec3(texture(texture_diffuse1, TexCoords));
	vec3 Specular = light.specular * spec * vec3(0.5, 0.5, 0.5); //vec3(texture(texture_specular1, TexCoords));

	return Ambient + Diffuse + Specular;
}



vec3 calculatePointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
	
	vec3 Ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));

	vec3 norm = normalize(normal);
	vec3 lightDir = normalize(light.position - fragPos);

	float diff = max(dot(norm, lightDir), 0.0);
	vec3 Diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));

	vec3 reflectDir = reflect(-lightDir, norm);
	float spec = pow(max(dot(reflectDir, viewDir), 0.0), material.shininess);
	vec3 Specular = light.specular * spec * vec3(texture(material.specular, TexCoords));

	// -- Attenuation -- //
	float dist = length(light.position - fragPos);
	float Attenuation = 1.0 / (light.constant + (light.linear * dist) + (light.quadratic * (dist * dist)));
	Ambient  *= Attenuation;
	Diffuse  *= Attenuation;
	Specular *= Attenuation;

	return Ambient + Diffuse + Specular;
	
	//return vec3(1.0);
}




vec3 calculateSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
	// For fun, we're going to ignore ambient here
	vec3 norm = normalize(normal);

	vec3 lightDir = normalize(fragPos - light.position);

	float theta = max(dot(lightDir, normalize(-light.direction)), 0.0);

	float diff = 1.0; 
	if (theta > light.cutoff)
	{
		diff = 0.0;
	}

	//float diff = step(light.cutoff , max(theta, 0.0));
	//float diff = 1.0;
	vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));

	return diffuse;
}




















// Per fragment
/*
1. The light's color factor
2. The constant factor: this is different for each of ambient, diffuse, and specular, per the phong model.
3. the mapping from texel to color that we're going to operate on using the first two factors
*/






/*
	// -- Light Attenuation -- //
	float distance = length(light.position - FragPos);
	float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

	// -- Ambient -- //	
	vec3 ambient = attenuation * light.ambient * vec3(texture(material.diffuse, TexCoords)); // Texture's mean ambient and diffuse are same color
	
	// -- Diffuse -- //
	vec3 norm = normalize(Normal);
	vec3 lightDir = normalize(light.position - FragPos);
	float theta = dot(lightDir, normalize(light.direction)); // The angle made between the fragmentToLight and the light's direction.
	float diff = 0.0;
	if (theta > light.cutoff)
	{
		diff = 1.0;
	}
	else
	{
		diff = max(1.0 - theta, 0.0) / 1.0;
	}
	//diff = step(light.cutoff, dot(lightDir, normalize(light.direction)));
	vec3 diffuse = attenuation * diff * light.diffuse * vec3(texture(material.diffuse, TexCoords));

	// -- Specular -- //
	vec3 viewDir = normalize(viewPos - FragPos);
	vec3 reflectDir = reflect(-lightDir, norm); 
	float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
	vec3 specularMap = vec3(texture(material.specular, TexCoords));
	vec3 specular = attenuation * spec * light.specular * specularMap;

	// -- Emissive -- //
	float emissiveStrength = 1.0;
	vec3 emis = emissiveStrength * vec3(texture(material.emissive, TexCoords + vec2(0.0, u_time)));
	vec3 emisMask = step(vec3(1.0), vec3(1.0) - specularMap);
	vec3 emissive = emis * emisMask;

	FragColor = vec4(ambient + diffuse + specular, 1.0);
*/