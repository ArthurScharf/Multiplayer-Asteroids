How do I write an output logger? I'm sick of rerunning the 
program. 





----------  KEY ---------- 
[ ] : Task. Will definitely be included in the project

( ) : Morphing task. Usually something to understand so an actual task can replace this one

--------------------------




Starting Point: Client receives a state and simply sets it's state to that state.



[ ] Rework movement so loop of main on client is processed as a desired input bit string
	[x] Create the appropriate input struct for the client to update the server with
	[x] create bitmasks for different user inputs
 
	>.  Remember that the server must track the delta time between the beginning of the current FFU and the moment 
	    an input request is received from the client. This is used to calculate the delta time for that specific update
		
	[x] Client must store requests. Client stores in a vector to iterate, server stores in queue since it processes all most recent
	    requests the moment they're received
		[x] Implement a map on the client that stores input strings with their respective ID
	
	[x] Client must send input bitstring
 
    [x] Server must receive & store client inputs each frame
		>. Each client connection stores a queue of inputRequest structs
			struct inputRequest
			{
				inputString
				delta_time between last received update OR start of FFU
				requestSequenceID
			}

	------------ Un-Committed changes below -------------

	[x] Calculate the delta time for received input requests (on the server per a client basis)
	
	[ ] Implement client update queue on server. Server stores all clients updates in their order received
		[ ] Client `secondsSinceLastRequest` must be set to 0 at the end of FFU
		[x] server must implement a queue that stores all client requests that will be batched
			> Implementation includes wrapping of incoming request packets to associate with correct client

	[x] Solve problem: When, during the FFU, does the server update the position of the asteroids (or other server owned actors?)
		> Update asteroid position at beginning of FFU. For time contraint purposes, we won't do substepping.
	
	[ ] Server must use a batch of inputs to update the server's state
		[ ] Server must ack clients based on the most recently processed state
	
	[ ] Upon receiving ACK, client must store most recently acked state, set it's current state to that state, then
	    reapply all non-acked states to the current state.
	
	( ) Consider how many inputs is reasonable. Locking the client's framerate might be a good idea
	
	( ) Consider Implementing collision between client actors
	
	( ) Do state sequence IDs still need to exist for the client? I think that input sequence IDs are sufficient
	
	( ) Consider substepping asteroid updates to get more accurate asteroid collisions
	
	
( ) delay processing of peer-actor data by at least one frame to allow for interpolation. This step should expand to 
    implementing said interpolation














