How do I write an output logger? I'm sick of rerunning the 
program. 





----------  KEY ---------- 
[ ] : Task. Will definitely be included in the project

( ) : Morphing task. Usually something to understand so an actual task can replace this one

--------------------------




Starting Point: Client receives a state and simply sets it's state to that state.



[ ] Rework movement so loop of main on client is processed as a desired input bit string
	[x] Create the appropriate input struct for the client to update the server with
	[x] create bitmasks for different user inputs
 
	>.  Remember that the server must track the delta time between the beginning of the current FFU and the moment 
	    an input request is received from the client. This is used to calculate the delta time for that specific update
		
	[x] Client must store requests. Client stores in a vector to iterate, server stores in queue since it processes all most recent
	    requests the moment they're received
		[x] Implement a map on the client that stores input strings with their respective ID
	
	[x] Client must send input bitstring
 
    [x] Server must receive & store client inputs each frame
		>. Each client connection stores a queue of inputRequest structs
			struct inputRequest
			{
				inputString
				delta_time between last received update OR start of FFU
				requestSequenceID
			}

	[ ] Calculate the delta time for received input requests

	[ ] Server must use a batch of inputs to update the server's state
	
	[ ] Server must ack clients based on the most recently processed state
	
	[ ] Upon receiving ACK, client must store most recently acked state, set it's current state to that state, then
	    reapply all non-acked states to the current state.
	
	( ) Consider how many inputs is reasonable. Locking the client's framerate might be a good idea
	
	( ) Do state sequence IDs still need to exist for the client? I think that input sequence IDs are sufficient
	
	
( ) delay processing of peer-actor data by at least one frame to allow for interpolation. This step should expand to 
    implementing said interpolation














