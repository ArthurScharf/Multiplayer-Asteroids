----- TODO -----
Move "Enter Server IP" code into loop so we don't need to restart client if server is not found

Alter Socket code to allow for recvfrom to work. recvfrom is blocking and we need the client and
the server to both send and receive data simultaneously. Note that we should avoid multiple threads




----- BUG -----





---- Design issues ----
Since one receiving of a packet occurs before a replication occurs, 
There is a race condition for client input to be processed

Despite the fact that the server doesn't use any rendering code, common classes stores the classes
used for this. Might be useful in the future, but for now, represents a point of confusion


---- Overview ----
OpenGL Rendering
 - GLFW (OpenGL implementation)
 - GLAD (OpenGL function definitions)
 - GLM  (OpenGL Math)
 - Assimp (Loading FBX Files for models)

WinSock for networking
 - Chat Feature
 - Replication
    - The server sends instructions to clients to spawn asteroids
    - The clients send their instructions to the server for character movement
    - The server implements player instructions, progresses asteroids and projectiles, then replicates
      these values back to the client.
    - Client side movement prediction (Stretch goal)

Collision Detection Solution
 - Each frame all objects are hashed into a 2d hashmap O(n)
 - Hash function --> object.xy coordinates rounded to closest value of R
 - R = Largest possible radial distance possible without collision
	- R = Player ship radius size + Asteroid size
 - Once objects are hashed, we check adjacent squares to each ship location. If asteroid occupies current ship square,
   OR occupies square adjacent to ship square, we calculate distance. If distance has collision, we collide
 - This algorithm is repeated for projectiles on the screen, comparing to asteroids for collision

Animation Solution
 - Asteroids will rotate around a random axis for their duration.
 - Ships will rotate so long as a turn key is held by a player
 - Ships will interp a ROLL to a max value while turning. (Stretch goal)

Menu Solution
 - We're going to avoid this for now. The server will only begin play when two players are connected.
   Once a player's connection is established, they see the game with only their ship. Once both player's have
   connected, we can begin having them move around





---------- Feature Order ----------
0. Figure out how to get the chat room working over the LAN
1. Build the server to be able to receive client connection and to replicate a vector back to the client
2. Build the rendering pipeline for the client. Have the pipeline replicate movement
3. Predictive movement for player ships. Asteroids lifespans and collision are server authority, but each client instances
   are handled by the client with respect to movement and animation
4. Extend replication to include gameplay features like asteroids, projectiles, and so on





---------- Code Design ----------
Since OpenGL is built to create a window and to handle input, OpenGL's input processing will be our program's
entrypoint for processing input

Question: How do I handle the difference between the frequency at which the server is replicating data, 
          and the processing speed of each computer? Obviously deltaTime handles the difference between processing speed,
          but what about the rate at which data is replicated?
Answer: This is what ping is. Games handle ping problems by removing players with terrible ping from games,
        so they don't ruin the experience of other players

game loop
 1. Collision
 2. Rendering


The server address is assigned in the code. Therefore, the client will always know where to connect to



----- Entities & Networking -----
Network must receive connection and notify client that other client has 
connected.
Things that must be sent over the network
 Player's existence
 Player positions
 Existence of projectiles (see player existence)
 
 All of this data is entity data. 

 Idea: Each time the server replicates, it sends a json object filled with
       the data for each entity. The client must check to see if 
       we see new entities. If we do, we spawn that entity

Common Entity Data
 Position
 Rotation
 Velocity

Client to Server Data
 Input



The client has an actor ID stored which represents the player character.

When a client joins the game, is sent the ID for it's character, so it can
set it. Actoring rendering is done agnostic to which character is the
player character.

Whenever the client detects an ID for a character is does not yet have,
it spawns that actor.



-- Schema --
first byte : message type.  0 == command, 1 == actor replication
remaining bytes : Depend on message type
 0 --> Command specific data
 1 --> [actor ID (unsigned int), Location (Vector3D), Rotation (Vector3D)] == 28 bytes

Server to Client Commands (Type 0)
 0. Connection Reply. This message stores the id for the actor the client will control





---- Timeline ----

Client sends server a connect request.

Server responds by instantiating an actor, and associating that actor with that clients ip addr

Server replies with command code '0', which contains that clients controlled actor

Client will instantiate it's own actor







QUESTION: What should store shaders?
ANSWER_1: Each actor stores a model. Each model stores a mesh. If each mesh would need to store
          unique shaders, then We'd want Mesh to have them. 

Question: What are the advantages of each mesh storing it's own shader?
 Each mesh on a model could shade itself completely differently than the others.
 Each shader is doing lighting using the phong model. The only difference is the texture used for each.
 Each mesh stores the texture's it will use. The intent is that each texture represents one of the 
 layers applied to create a material. 
 Thus, we don't need the mesh to store the shaders.

Question: What are the advantages of the Model storing the shader?
 The whole model experiences the same lighting in our application. Thus, each actor storing the shader.
 BUT all the shaders need to have global lights set. These lights affect all the actors.
 While it would be feasible to set light parameters within each shader through each actor, this seems like an
 extra step.





---- Serialized client input Design ----
We must serialize user input so it can be read by server and be replicated back to all clients

PROBLEM: What if I want to include new input possibilities? I need a solution that can be easily extended
 --> Define a maximum size for data to be sent. Define an efficient encoding schema. new inputs can be extended to use unused space


Solution: Shaders are stored as globally as possible; in the client. 








---- PROBLEM: There is latency between the client and server ----
Hypothesis:
 UDP sockets have a buffer for messages. My server is much faster than the client. The server is sending an actor replication
 message each cycle, which will fill up the buffer on the client side.
 The internet has told me that if a message arrives and there is no room in the buffer, said message is dropped without error.
 Since the server is much faster than the client, the messages that contain updated player position are being buried and sometimes 
 lost behind a wall of the previous message

Solution: 
 Each time a message needs to be read, rip messages until we find a message of the type we desire or,
 the better choice, read every message from the buffer until we read the last message, then use that.

PROBLEM: some of the packets stored in the buffer are not state updates and thus, cannot be discarded.

SOLUTION: Each frame with the client, have said client read ALL the packets in the buffer and store them based on their message type.
          For packets that store game state update data, simply choose the discard all the messages that aren't the most recently 
          received packet


PROBLEM: The client is still consuming server-snapshots more slowly than the server. Further, the delta time calculation necessary 
	 for the client will differ from the server

QUESTION: Will a different delta time matter for the client and server if the client is copying snapshots?
ANSWER: Not conceptually. Those snapshots have the server's delta time encoded into it. The issue is is then getting the client
        to copy state at the same rate that the server sends it.
	
NOTE: In essence, the delta time DOES matter, but not for calculations. It matters that the client consumes snapshots at the same rate
      that the server sends them because those snapshots will have delta time encoded into the changes in position.

QUESTION: Does client delta time matter for interpolation?
          So long as server and client delta times are calculated relative to the same time interval (a second), delta time's can differ
          for the purpose of interpolation




PROBLEM: No matter the rate of updates sent to/from server, the differing delta time is an issue.
         Even if the server is consuming updates 1:1 with the client sending them, differing delta times will result
         in differing distances traveled relative to the speed if the client was moving its own actor.
SOLUTION: The solution seems to be to update the simulation using a constant net update. In other words, all values are updated
          relative to the number of updates, NOT the speed of the program. The speed of the program only matters as a means to read
          game states
PROBLEM: Is this totally true? the client will need to interpolate between packets to allow for smoother movement. Doing this will
         require a delta time to handle varying frame rate. In this case, we need to understand how to properly interpolate 
         between game states


---- Interpolating Between Game States ----
Synchronized net updates (client and server use the same deck of cards, even though the client gets its cards late)

"Synchronize The Simulation". Everyone deals with quantized game states. Yes, each gamestate represents a constant difference in time.
Game states like a deck of cards. Problems are now related to dealing with the rate of consumption of cards

The client receives a snapshot in T time. T = server_update_rate + RTT/2


Must save each state update from the server in a circular buffer.
Client is ahead of server. ie the clients world state is chronologically ahead of the server
--> State replies from server will always be for a previous state in time.
We must be able to compare the just received state to the previously predicted client side state.
--> The client must also store it's own circular buffer of states
There must be a way to match the paired states, one of client, one from server.
--> States must sequential update numbers 
If client creates states too quickly, it will overwrite states yet to be compared to their server counterpart.
--> Server & Client must generate and consume states at almost the same rate

QUESTION: Can I simply have the client only create a new state whenever it receives one from the server? 
    the newly created state in this way won't be the counterpart to the one we've just received, since the client is ahead,
    but it will mean we never over create states and lose older one's that are needed

---- Circular Buffer Design ----
Encapsulation will keep the main code clean. Avoids bugs
Simply a wrapper for an array of arrays of actors