----- TODO -----
Move "Enter Server IP" code into loop so we don't need to restart client if server is not found

Alter Socket code to allow for recvfrom to work. recvfrom is blocking and we need the client and
the server to both send and receive data simultaneously. Note that we should avoid multiple threads

Properly design the communication sequences between client and server then implement it



---- Design issues ----
Since one receiving of a packet occurs before a replication occurs, 
There is a race condition for client input to be processed

Despite the fact that the server doesn't use any rendering code, common classes stores the classes
used for this. Might be useful in the future, but for now, represents a point of confusion


---- Overview ----
OpenGL Rendering
 - GLFW (OpenGL implementation)
 - GLAD (OpenGL function definitions)
 - GLM  (OpenGL Math)
 - Assimp (Loading FBX Files for models)

WinSock for networking
 - Chat Feature
 - Replication
    - The server sends instructions to clients to spawn asteroids
    - The clients send their instructions to the server for character movement
    - The server implements player instructions, progresses asteroids and projectiles, then replicates
      these values back to the client.
    - Client side movement prediction (Stretch goal)

Collision Detection Solution
 - Each frame all objects are hashed into a 2d hashmap O(n)
 - Hash function --> object.xy coordinates rounded to closest value of R
 - R = Largest possible radial distance possible without collision
	- R = Player ship radius size + Asteroid size
 - Once objects are hashed, we check adjacent squares to each ship location. If asteroid occupies current ship square,
   OR occupies square adjacent to ship square, we calculate distance. If distance has collision, we collide
 - This algorithm is repeated for projectiles on the screen, comparing to asteroids for collision

Animation Solution
 - Asteroids will rotate around a random axis for their duration.
 - Ships will rotate so long as a turn key is held by a player
 - Ships will interp a ROLL to a max value while turning. (Stretch goal)

Menu Solution
 - We're going to avoid this for now. The server will only begin play when two players are connected.
   Once a player's connection is established, they see the game with only their ship. Once both player's have
   connected, we can begin having them move around





---------- Feature Order ----------
0. Figure out how to get the chat room working over the LAN
1. Build the server to be able to receive client connection and to replicate a vector back to the client
2. Build the rendering pipeline for the client. Have the pipeline replicate movement
3. Predictive movement for player ships. Asteroids lifespans and collision are server authority, but each client instances
   are handled by the client with respect to movement and animation
4. Extend replication to include gameplay features like asteroids, projectiles, and so on





---------- Code Design ----------
Since OpenGL is built to create a window and to handle input, OpenGL's input processing will be our program's
entrypoint for processing input

Question: How do I handle the difference between the frequency at which the server is replicating data, 
          and the processing speed of each computer? Obviously deltaTime handles the difference between processing speed,
          but what about the rate at which data is replicated?
Answer: This is what ping is. Games handle ping problems by removing players with terrible ping from games,
        so they don't ruin the experience of other players

game loop
 1. Collision
 2. Rendering


The server address is assigned in the code. Therefore, the client will always know where to connect to



----- Entities & Networking -----
Network must receive connection and notify client that other client has 
connected.
Things that must be sent over the network
 Player's existence
 Player positions
 Existence of projectiles (see player existence)
 
 All of this data is entity data. 

 Idea: Each time the server replicates, it sends a json object filled with
       the data for each entity. The client must check to see if 
       we see new entities. If we do, we spawn that entity

Common Entity Data
 Position
 Rotation
 Velocity

Client to Server Data
 Input



The client has an actor ID stored which represents the player character.

When a client joins the game, is sent the ID for it's character, so it can
set it. Actoring rendering is done agnostic to which character is the
player character.

Whenever the client detects an ID for a character is does not yet have,
it spawns that actor.



-- Schema --
first byte : message type.  0 == command, 1 == actor replication
remaining bytes : Depend on message type
 0 --> Command specific data
 1 --> [actor ID (unsigned int), Location (Vector3D), Rotation (Vector3D)] == 28 bytes

Server to Client Commands (Type 0)
 0. Connection Reply. This message stores the id for the actor the client will control





---- Timeline ----

Client sends server a connect request.

Server responds by instantiating an actor, and associating that actor with that clients ip addr

Server replies with command code '0', which contains that clients controlled actor

Client will instantiate it's own actor







QUESTION: What should store shaders?
ANSWER_1: Each actor stores a model. Each model stores a mesh. If each mesh would need to store
          unique shaders, then We'd want Mesh to have them. 

Question: What are the advantages of each mesh storing it's own shader?
 Each mesh on a model could shade itself completely differently than the others.
 Each shader is doing lighting using the phong model. The only difference is the texture used for each.
 Each mesh stores the texture's it will use. The intent is that each texture represents one of the 
 layers applied to create a material. 
 Thus, we don't need the mesh to store the shaders.

Question: What are the advantages of the Model storing the shader?
 The whole model experiences the same lighting in our application. Thus, each actor storing the shader.
 BUT all the shaders need to have global lights set. These lights affect all the actors.
 While it would be feasible to set light parameters within each shader through each actor, this seems like an
 extra step.

Solution: Shaders are stored as globally as possible; in the client. 
